## LeetCode琅琊榜第二十二层-数组中两个数的最大异或值

[TOC]

## 题目

### 题目浏览

![image-20220603111512765](E:\暂存\博客\暂存图片\image-20220603111512765.png)

![image-20220603111718650](E:\暂存\博客\暂存图片\image-20220603111718650.png)

### 题目信息解读

- 返回`num[i] ^ nums[j]`的最大的运行结果,所以我们要找到数组中对应两个下标的元素,使他们达到`异或`最大值
- `1 <= nums.length <= 2000,0`说明长度不可能为0,故<font color = red>**不需要校验特殊情况**</font>
- `0 <= nums[i] <= 2^31-1`说明,每一个元素都是在一个`int`范围内的,`隐式说明有32个比特位`

### 案例分析

```java
输入：nums = [3,10,5,25,2,8]
输出：28
解释：最大运算结果是 5 XOR 25 = 28.
```

```java
输入：nums = [0]
输出：0
解释: 只有一个数字,最大的运算结果只能是其本身
```

```java
输入：nums = [2,4]
输出：6
解释: 只有两个数字,最大的运算结果只能是 2 XOR 4 = 6,自身XOR自身 = 0
```

```Java
输入：nums = [8,10,2]
输出：10
解释: 最大的运算结果是 8 XOR 2 = 10
```

## 算法概述

### 二进制+dp算法+贪心算法

- 该算法依然运用到了琅琊榜第二十一层的代码思想,但是不同的是,该算法在此基础上运用到了DP的思想

## 算法详解

### 异或性质分析

```java
// 假设有三个变量,分别为variable1[变量1],variable2[变量2],result[结果]
// 有以下的转换关系
	variable1 ^ variable2 = reslut [=代表的不是赋值,是等于]
	variable2 ^ reslut = variable1
// 验证如下
    10 ^ 2 = 8
// 二进制位如下所示(默认8位,省事)
	[10] 0000 1010
    [2]  0000 0010
    [8]  0000 1000
    10 ^ 8 = 2
    [10] 0000 1010
    [8]  0000 1000
    [2]  0000 0010  
```

### 算法思路

`该算法是基于二进制,所以,算法思路都对应着数据的二进制,在思考时应当作出对应的转换`

1. 从最高位开始,分别取出每一个数字自第`K`位到最高位的二进制数字,并将这些数字存放在`Set`集合中
2. 假设第`k`位的结果是`1`,用该结果分别`异或`前`k`位的二进制,如果在`Set`集合中能取到对应的值,该位置就是`1`,否则是`0`
   1. 注意:这里运用到了`异或性质`,请看`异或性质分析`
   2. 且这里用到了`贪心`的思想
3. 重复该步骤,直至将所有的`二进制位`填上对应的数值即可得到`最大值`

### 算法图解

![image-20220603201527888](暂存图片/image-20220603201527888.png)

## 代码实现与分析

### 代码实现

```Java
class Solution {
    // 我们设置最高位的下标为30,详情请看解析1
    public final int BIG_BIT_OFFSET = 30;
    public int findMaximumXOR(int[] nums) {
        // 最终结果result
        var result = 0;
        // 对应着算法图解从最高位开始
        for (int k = BIG_BIT_OFFSET; k >= 0; k--) {
            // 对应的Set集合,用于存放v2
            var set = new HashSet<Integer>();
            // 将每一个元素的前K个二进制位放在Set集合中
            for (var num : nums) {
                // 这里不需要&1,如果&1只能拿到一个二进制位
                set.add(num >> k);
            }
            // 假设Set集合中不存在
            var flag = false;
            // 第K位的总和应该设为下面的形式,详情请看解析2
            // curResult为假设的结果
            var curResult = 2 * result + 1;
            for (var num : nums) {
                // 相当于v1 ^ reslut,如果成立,说明v2存在,说明该二进制位假设正确,改flag
                if (set.contains((num >> k) ^ curResult)) {
                    flag = true;
                    break;
                }
            }
            // 根据flag就可以知道是否该二进制位为1
            if (flag) {
                // 如果是,将假设的给最终
                result = curResult;
            }else {
                // 否则,假设-1就是最终的,因为假设不成立,该二进制位是0,比原来少了1
                result = curResult - 1;
            }
        }
        return result;
    }
}
```

#### 解析1

- 据我们了解,一个`int`有`32bit`即`32位`,理应下标应该要达到31才行,但是这里是30
- 因为`0 <= nums[i] <= 2^31-1`,符号位一定为0,不需要去管符号位,所以只需要`31位`

#### 解析2

- 从算法图解中的`result`不难推出该表达式

- 如果这个二进制位是1,那么相当于有如下情况

  - ```Java
    二进制        十进制
    1 -> 11  即 1 -> 3
    11 -> 111 即 3 -> 7
    110 -> 1101 即 6 -> 13
    ```

## 算法总结

> 该算法耦合了许多传统算法,具有极大的优越性,除了该算法,这个题目还有通过前缀树的算法来解答此题,所以,下一篇我会着重分析如何构建前缀树.
