# LeetCode琅琊榜第二十七层-下一个更大的元素 I

## 题目简述

### 题目

### 要点

- <B>下一个更大元素的释义</B>

  - 是指`nums1`中对应的数字x,在`nums2`中对应位置的右侧第一个比他大的数字

- `nums1`和`nums2`<B>没有重复数字</B>,其中``nums1`是`nums2`的子集

  - 说明`nums2`出现的元素,`nums1`都有,所有每一个`nums1`的数字在`nums2中`都可以找到其对应的位置,不存在不存在的情况

- 如果可以找到对应的下一个更大的元素,则返回这个元素的数值,否则返回-1,注意的是,返回值是一个数组

- ```Java
  1 <= nums1.length <= nums2.length <= 1000 // 不需要考虑空数组以及长度为0的情况吗
  0 <= nums1[i], nums2[i] <= 104 // 所有的数字都大于0
  ```

### 误区

- 题目中的下一个更大的元素的意思并不是紧邻的下一个比他大,而是右边的所有元素有一个比他大就可以进行下一步分析

## 示例分析

### 示例一

```java
输入：nums1 = [4,1,2], nums2 = [1,3,4,2].
输出：[-1,3,-1]
解释:
--- [4]  ---[4,2] 明显,4后面没有比他大的数字,返回-1
--- [1]  ---[1,3,4,2] 明显,1后面的3,4都比他大,第一个比他大的就是3,返回3
--- [2]  ---[] 明显,2后面没有元素,直接返回-1  
```

### 示例二

```Java
输入：nums1 = [2,4], nums2 = [1,2,3,4].
输出：[3,-1]
解释:
--- [2]  ---[2,3,4] 明显,后面的3,4都比2大,第一个最大的是3,返回3
--- [4]  ---[] 明显,4后面没有元素,直接返回-1    
```

## 算法分析

### 暴力求解-快排思想

#### 算法思想

- 我们首先依次获取`nums1`数组中的每一个元素
- 然后通过遍历在`nums2`数组中找到对应的元素
- 找到对应的元素后继续遍历`nums2`数组找到第一个比他大的元素

#### 算法缺陷

- (最坏)时间复杂度为`O(nums1,length * nums2.length)`
- 该时间复杂度较高,算法效率较低

### 栈+哈希表

#### 算法思想

- 我们利用哈希表来记录每一个元素的情况,即`key = 元素&value = 结果`
- 我们通过栈来判断是否有结果

#### 算法优点

- (最坏)时间复杂度为`O(nums1.length + nums2.length)`
- 从平方阶到线性阶,算法效率高

## 代码实现

### 暴力求解-快排思想

```Java
public int[] nextGreaterElement(int[] nums1, int[] nums2) {
    // m,n分别记录两个数组的长度
    int m = nums1.length;
    int n = nums2.length;
    // resArr是记录结果的数组,该数组的长度就是m,因为nums1的每一个元素都只存在一个结果,所以有m个结果
    int[] resArr = new int[m];
    // 外层for循环用于遍历nums1,获取每一个值及其对应的结果
    for (int i = 0; i < m; i++) {
        // 从索引为0处,开始遍历
        int j = 0;
        // 如果找不到对应的数字,一直移动j,直到找到为止
        while (j < n && nums1[i] != nums2[j]) {
            j++;
        }
        // 比他大的数字一定在他的右侧,初始化j + 1
        int k = j + 1;
        // 同理得,如果找不到比他的的数字,就一直移动k,直到找到找到为止
        while (k < n && nums2[k] <= nums1[i]) {
            k++;
        }
        // 如果 k == n,说明全部遍历完了,k依然自增,说明全都小于等于该元素,即没有比他大的元素,返回-1
        // 否则返回索引k对应的元素
        resArr[i] = k < n ? nums2[k] : -1;
    }
    return resArr;
    // 注意:中间的两个while将平常的三次方阶变成二次方阶,这并不是一个纯纯的暴力求解,也有值得学习的地方
}
```

### 栈+哈希表

```Java
public int[] nextGreaterElement(int[] nums1, int[] nums2) {
    // 分别用m,n记录数组长度
    int m = nums1.length;
    int n = nums2.length;
    // 创建对应的HashMap和Stack
    HashMap<Integer,Integer> map = new HashMap<>();
    Stack<Integer> stack = new Stack<>();
    // 用于记录结果的数组
    int[] resArr = new int[m];
    // 从后往前遍历,解析1
    for (int i = n - 1; i >= 0; i--) {
        // 获取对应的元素
        int num = nums2[i];
        // 解释2
        while (!stack.isEmpty() && num > stack.peek()) {
            stack.pop();
        }
        // 根据解释1的定义,如果栈为空,即没有比他大的元素,返回-1,否则返回栈顶元素
        map.put(num,stack.isEmpty() ? -1 : stack.peek());
        // 压栈
        stack.push(num);
    }
    // 根据算法思想,将结果放到resArr即可
    for (int i = 0; i < m; i++) {
        resArr[i] = map.get(nums1[i]);
    }
    return resArr;
}
```

#### 解析1

- 首先,我们想利用栈来解决问题,我们需要明确栈是,栈具有**先入后出,后入先出**的特性
- 其次,我们定义,如果栈为空,说明该元素没有比他大的元素,这个定义是可行的,比如
  - 我们压入最后一个元素,显然压入之前栈为空,而且最后一个元素也不可能有一个比他大的元素
- 再者,如果我们从前往后的话,当我们压入栈中,前面的元素处于非活跃状态,无法取出更无法判断
- 所以不论怎么样都是要从后往前遍历

#### 解释2

- 首先,我先先看循环体,里面是一个弹栈操作
- 其次,我们再看布尔表达式,因为有弹栈操作,所以我们需要判断不为空,很好理解
- 再者,为什么`num`比栈顶元素大就要弹栈?
  - 因为,如果`num`比栈顶元素大,该元素不可能是大于`num`的第一个元素,没有意义弹栈即可
  - 也因为,如果`num`前面的元素有比其大的元素,也永远不可能是该栈顶元素,因为num比他大,第一个大至少是num,所以还是没有意义,弹栈即可

## 算法总结

> ​	遇到两个数组的情况,不只有双指针,还有栈+哈希表