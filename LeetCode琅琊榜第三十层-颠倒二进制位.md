# LeetCode琅琊榜第三十层-颠倒二进制位

## 题目解析

### 题目

### 要点

- 针对于Java而言,底层是没有`unsigned`这一系列的无符号类型的,所以,对于Java而言需要考虑的情况会更多一些,一些常用的方法不可以使用
- 输入是一个长度为`32`的二进制字符串,说明是一个`int`类型的数字

## 示例分析

### 示例一

```Java
输入：n = 00000010100101000001111010011100
输出：DEC 964176192  BIN: 00111001011110000010100101000000
```

### 示例二

```Java
输入：n = 11111111111111111111111111111101
输出：3221225471 (10111111111111111111111111111111)
注意:该结果是c++的,对于Java一定是一个负数即-3,不影响结果    
```

## 算法分析

### 逐位颠倒法

#### 算法思路

- 通过位运算可以轻易获取到某一个二进制位的值
- 我们可以自低位向高位依次获取每一个二进制位,然后自高位向低位依次赋上每一个二进制位就可以完成颠倒

### 分治算法

#### 算法前提

> **该算法运用到了如下的思想**,比如有如下字符串需要被颠倒
>
>  A B C D 颠倒后 D C B A 
>
>  颠倒顺序 1.A B交换,C D交换  B A D C 
>
> ​				2.BA DC交换 D C B A
>
>  即完成了颠倒

#### 算法思路

- 根据上述的思想,来完成对二进制的颠倒操作
- 由于位数众多,所以,根据以上的思想分治解决问题

## 代码实现

### 逐位颠倒法

```Java
public int reverseBits(int n) {
    // 用于存放结果的变量,初始化为0,初始化为0,所有的二进制位都是0,方便计算
    int res = 0;
    // 遍历每一个二进制位,解析1,解析2
    for (int i = 0;n != 0; i++) {
        res |= (n & 1) << (31 - i);
        n >>>= 1;
    }
    return res;
}
```

#### 解析1

1. `n&1`的目的是获取第一个二进制位,即获取最低位
2. `(31 - i)`因为`i`初始化为0,所以将第一位左移31位刚好到最高位
3. `res`被初始化位`0`,给他`|=`该运算符可以得到每一次获取到的数字
4. 因为最低位已经被移动,所以`>>>`无符号右移一位,便于下次获取(每次获取第一位,将移动过的舍弃掉)

#### 解析2

1. `for循环`结束的条件是`n != 0`,当`n==0`的时候,颠倒已经没有意义了,全是`0`,颠了等于没颠

### 分治算法

```Java
// 解析3
public static final int M1 = 0x55555555;
public static final int M2 = 0x33333333;
public static final int M4 = 0x0f0f0f0f;
public static final int M8 = 0x00ff00ff;
public int reverseBits(int n) {
    // 解析4,解析5
    n = (n >>> 1) & M1 | (n & M1) << 1;
    n = (n >>> 2) & M2 | (n & M2) << 2;
    n = (n >>> 4) & M4 | (n & M4) << 4;
    n = (n >>> 8) & M8 | (n & M8) << 8;
    n = n >>> 16 | n << 16;
    return n;
}
```

#### 解析3

```JAVA
// 16进制对照2进制
// HEX 0x55555555 BIN 0101 0101 0101 0101 0101 0101 0101 0101 
// HEX 0x33333333 BIN 0011 0011 0011 0011 0011 0011 0011 0011
// HEX 0x0f0f0f0f BIN 0000 1111 0000 1111 0000 1111 0000 1111
// HEX 0x00ff00ff BIN 0000 0000 1111 1111 0000 0000 1111 1111
```

#### 解析4

- `n >>> 1`即将n无符号右移一位,造成的结果是所有的偶数位都到了奇数位上
- `& M1`,根据`M1`的二进制位,奇数位都是`&1`,偶数位都是`&0`所以n现在的偶数位全部变成0,奇数位全部保留,结果是偶数位移动到奇数位上保留下来,奇数位全部删除
- `n & M1`,将所有的偶数位变成了0,获得所有的奇数位,然后左移一位,结果是保留所有的奇数位然后想左移动一位将奇数位变成偶数位,并把偶数位全部删除
- `|`通过该操作符将两个结果拼接起来,实现了奇数位和偶数位换位置,就是**算法前提提到的步骤**

#### 解析5

- 上面那个步骤完成了`1 对 1`的交换,对应着`A 与 B交换 C 与 D交换`
- 所以解析来我们要完成`2 对 2`的交换,对应着`BA 与 DC交换`,所以M2变成了那个样子,后面也变成了2
- 同理得
- 根据前提条件,我们不妨可以得到结束条件就是对称交换,所以`结束是16位`

## 算法总结

> ​	主要是法二运用到的分治算法也是底层Integer的reverse()方法的源码