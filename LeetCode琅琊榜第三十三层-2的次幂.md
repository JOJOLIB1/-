# LeetCode琅琊榜第三十三层-2的次幂

## 题目概述

### 题目

### 要点

> - `范围[Integer.MIN_VALUE,Integer.MAX_VALUE]`,说明在一个整形的范围内,不需要额外的考虑,本来就是一道很简单的题目

## 算法分析

### 二进制算法

- 我们可以通过取二进制中最低的1来判断
- 且如果某个数字是二的次幂,说明该数字的二进制位中只会有一个1
- 特别的是,对于`-1,-2`等数字,2的N次幂的得数一定大于0,所以,小于0的一定错误,而且底层存储的是补码,也不可能只有一个1

#### 法一:

> `n & (n - 1) == 0`
>
> <font color = red>**原理:**</font>
>
> 1. 假设我们有以下两个二进制位
>    - (?)<sub>10</sub>   (a100)<sub>2</sub>
>    - (? - 1)<sub>10</sub>   (a011)<sub>2</sub>
> 2. 我们的目的是找出第一次出现的1,即最低位的1,因为他是第一个1,所以后面要么没有0,要么全是0
> 3. 当这两个结果进行按位与操作的时候,这个位数及其更低位一定是0,此刻得数的决定权在高位
> 4. 如果高位的结果不等于0,说明有1的存在,不符合只有一个1的条件,同理得

#### 法二:

> `n & (-n) == n`
>
> <font color = red>**原理:**</font>
>
> 1. 首先先明确的是,底层都是以补码的形式存储数据的,而正数变成负数,按位取反并加1
> 2. 例子
>    - (?)<sub>10</sub>   (a100)<sub>2</sub>
>    - (-?)<sub>10</sub>   (a100)<sub>2</sub>
>    - 按位与之后,前面a位的结果一定为0,后面的东西不变,如果按位与之后的结果与原来的一致,说明只有一个1,符合条件,否则说明原来前面一定会有其他的1,才导致的不相同,有多个1,不符合条件

## 代码实现

```java
    public boolean isPowerOfTwo(int n) {
        return n > 0 && (n & (-n) )== n;
        return n > 0 && (n & (n - 1)) == 0;
    }
```

