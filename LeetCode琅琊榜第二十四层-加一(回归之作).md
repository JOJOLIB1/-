# LeetCode琅琊榜第二十四层-加一(回归之作)

## 题目简述

## 示例

### 示例分析

示例一

```java
输入:digits = [1,2,3]
输出:[1,2,4]
解释:123 + 1 = 124
```

示例二

```java
输入:digits = [1,2,9]
输出:[1,3,0]
解释:129 + 1 = 130
```

示例三

```
输入:digits = [9]
输出:[1,0]
解释:9 + 1 = 10
```

### 规律解读

- `+1`显而易见,如果最后一个数字不是`9`的情况下,直接在最后一个数字`+1`即可
- 如果最后一个数字是`9`的情况下,我们需要看前面一位数字是不是`9`,如果不是往前一位`+1`即可
- 如果`全是9`的情况下,我们需要考虑扩容

## 算法解读

### 算法概述

- 该题本质就是想让我们找`9`这个数字,如果不是`9`,简单的`+1`即可
- 如果是`9`,就向前面去判断

### 算法思想

- 根据小学知识,我们的<b>加法</b>都是从个位开始的,所以,遍历应该从最后一个元素开始
- 如果<B>该元素等于9</B>,向前遍历
- 如果<B>该元素不等于9</B>,有以下两种情况
  1. 数组被遍历完
     - 在该位置上`+1`,并将后面的`9`都置为`0`,并返回
  2. 数组没有被遍历完
     - 创建一个新的数组,在偏移量为0的位置置为`1`,并返回

## 代码实现

```Java
    public int[] plusOne(int[] digits) {
        // 获取digits长度,善用变量的算法思想,要用变量去标识一些特殊变量,避免自己会写错
        int n = digits.length;
        for (int i = n - 1; i >= 0; i--) {
            // 如果是9,则往前遍历
            if (digits[i] != 9) {
                // 执行到这说明后面的全是9,这里不是9,直接自增1即可
                digits[i]++;
                // 详情请看解析1
                for (int j = i + 1; j < n; j++) {
                    digits[j] = 0;
                }
                // 如果非9的位置自增后,说明任务完成辽,直接退出
                return digits;
            }
        }
        // 执行到这,只有一种可能,上面的if条件始终进不去,说明全是9
        // 获取一个增容数组,第一个赋值为1,直接返回即可
        int[] res = new int[n + 1];
        res[0] = 1;
        return res;
    }
```

### 解析1

- 该`for`循环的目的是将后面所有的`9`都赋值为`0`,为什么要这样做呢?
  - 很简单,为了`逢十进一`,例如`199 + 1 = 200`

## 算法扩展

### 概述

- 通过上面的算法不禁可以让我们联想到,是否可以将该算法拓展到更多的领域

### 例子

- `让我们在二进制数组上完成+1操作`
- `让我们在八进制数组上完成+1操作`
- `让我们在十六进制数组上完成+!操作`
- <b>`让我们在N进制数组上完成+M操作`</b>
- .....

### 解决措施

- 很简单,我们只需要在`if(digits[i] != 9)`做出对应的修改即可
- 例如二进制,需要改成`if(digits[i] != 1)`
- 十六进制可能会有点麻烦,但总体上是如此的

## 算法总结

> ​	该类型的算法题,不论是加几,我们找影响前面数字的数字即可
>
> ​	总结,**十进制找9,二进制找1,八进制找7**